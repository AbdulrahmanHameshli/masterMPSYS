% [scan, beacons] = RayTrace(xr,Gs,Gp,PhiReso,Rs)%% Given the segment map 'Gs', the beacon map 'Gp' and the pose xr = [x,y,theta],% this function generates the scan and the beacons seen from xr as the result of% a 360 deg-ray tracing with angular resolution PhiReso and maximal perception% radius Rs.% v.0.1, 2003-08-04, koa% v.1.1, 2003-08-07, koa: Gp added% Dec 2014: TODO BUG FIX: for some phi's, segments are wrongly declared% as invisible. Then maxrange is returned instead of the proper distance.function [scan, beacons] = RayTrace(xr,Gs,Gp,PhiReso,Rs)% Constants for feature mapPointID = 1;      % id for point and angular featuresLineID  = 2;      % id for infinite linesSegmID  = 0;      % id for segment features. phi is defined as follows:% [0..pi[ if origin is in open space and ]0..-pi] elseNone = 0;         % says that nothing is visible from the current cell% Constants for numerical issuesEpsi = 1E-12;     % used as 0 threshold necessary since e.g. sin(pi)~=0!EpsiPF = Epsi;    % used to define visibility of point features on segm/linesEpsiPhi = 1E-12;  % to avoid 0,pi/2-aligned rays posing tricky num. problemsGl = [];% ---------------------------------------------------------------------------------- %% 1. Initialize feature mapfor i = 1:length(Gs)  Gs(i).id = Gs(i).lid;  xs = Gs(i).x(1);  ys = Gs(i).x(2);  xe = Gs(i).x(3);  ye = Gs(i).x(4);  xc = (xs + xe)/2;  yc = (ys + ye)/2;  len = sqrt((ye-ys)*(ye-ys) + (xe-xs)*(xe-xs));  phi = atan2(ye-ys, xe-xs);  alpha = phi + pi/2;  r = xs*cos(alpha) + ys*sin(alpha);  if r >= 0    if phi >= pi, phi = phi - 2*pi; end    while phi <  0, phi = phi + pi; end  else    if phi <  pi, phi = phi + 2*pi; end    while phi >= 0, phi = phi - pi; end  end  Gs(i).x(1) = xc;  Gs(i).x(2) = yc;  Gs(i).x(3) = phi;  Gs(i).x(4) = len;end% define intermediate data structure for feature map -> FF = [];nL = length(Gl); nS = length(Gs); nP = length(Gp);for i = 1:nL, F = [F; Gl(i).x(1:2), -1, -1, LineID, Gl(i).id]; endfor i = 1:nS, F = [F; Gs(i).x, SegmID, Gs(i).id]; endfor i = 1:nP, F = [F; Gp(i).x, -1, -1, PointID, Gp(i).id]; endnF = size(F,1);vPtsF = find(F(:,5)==PointID)';vLneF = find(F(:,5)== LineID)';vSgmF = find(F(:,5)== SegmID)';vphi = (xr(3):PhiReso:xr(3)+2*pi-PhiReso)+EpsiPhi;% ---------------------------------------------------------------------------------- %% 2. Perform ray tracingx = xr(1);y = xr(2);%%% --- Intersect with all map POINT features using the possible psi's%%% --- search for candidates potentially visible from x,ynCand = 0;for fIdx = vPtsF  d = sqrt((F(fIdx,1)-x)^2+(F(fIdx,2)-y)^2);  if d < Rs    psi = atan2(F(fIdx,2)-y,F(fIdx,1)-x);    if psi < 0, psi = psi + 2*pi; end    nCand = nCand + 1;    ptFCand(nCand).d = d;    ptFCand(nCand).psi = psi;    ptFCand(nCand).fID = F(fIdx,6);  endend% Verify visibility of point feature candidatesnLneF = length(vLneF);nSgmF = length(vSgmF);beacons = [];ibeacons = 1;for c = 1:nCand  fID = ptFCand(c).fID;  visible = 1;                          % start with true-hypothesis    % with lines  i = 1;   while visible && (i <= nLneF)    fIdx = vLneF(i);    [Pint,flag] = intersectRayAndLine([x y ptFCand(c).psi],F(fIdx,1:2));    if flag >= 0      dp = ptFCand(c).d;      dint = sqrt((Pint(1)-x)^2+(Pint(2)-y)^2);      if dint >= dp - EpsiPF            % is l behind or in front of P?        if (abs(dp - dint) <= EpsiPF) && (flag == 0)  % is P on l (Epsi)?          visible = 0; fID = None;      % P is on l where l is invisible        end      else        visible = 0;                    % l is in front of P        fID = None;      end    end    i = i + 1;                          % l does not intersect with ray  end    % with segments  i = 1;  while visible && (i <= nSgmF)    fIdx = vSgmF(i);    [Pint,flag] = intersectRayAndSegm([x y ptFCand(c).psi], F(fIdx,1:4));    if flag >= 0      dp = ptFCand(c).d;      dint = sqrt((Pint(1)-x)^2+(Pint(2)-y)^2);      if dint >= dp - EpsiPF           % is s behind or in front of P?        if (abs(dp - dint) <= EpsiPF) && (flag == 0)  % is P on s (Epsi)?          visible = 0; fID = None;      % P is on s where s is invisible        end      else        visible = 0;                    % s is in front of P        fID = None;      end    end    i = i + 1;                          % s does not intersect with ray  end    % register visible candidates  if fID ~= None    beacons(ibeacons,1) = ptFCand(c).psi-xr(3);    beacons(ibeacons,2) = ptFCand(c).d;    beacons(ibeacons,3) = fID;    ibeacons = ibeacons + 1;  endend%%% --- Intersect with all map LINES and SEGMENTS%%% ---iscan = 1;for phi = vphi  dMin = Inf;    % Intersect with all map LINES  for fIdx = vLneF    [Pi,flag] = intersectRayAndLine([x y phi],F(fIdx,1:2));    if flag >= 0      d = sqrt((x-Pi(1))^2+(y-Pi(2))^2);      if (d < Rp) & (d < dMin + Epsi)        dMin = d;        % is it really visible?        if flag > 0, fID = F(fIdx,6); else fID = None; end      end    end  end    % Intersect with all map SEGMENTS  for fIdx = vSgmF    % make first visibility test: ray within endpoint angles?    xe1 = F(fIdx,1)+F(fIdx,4)/2*cos(F(fIdx,3));    ye1 = F(fIdx,2)+F(fIdx,4)/2*sin(F(fIdx,3));    xe2 = F(fIdx,1)-F(fIdx,4)/2*cos(F(fIdx,3));    ye2 = F(fIdx,2)-F(fIdx,4)/2*sin(F(fIdx,3));    psi1 = atan2(ye1-y,xe1-x);    psi2 = atan2(ye2-y,xe2-x);    if psi1 < 0, psi1 = psi1 + 2*pi; end  % works since atan2 returns    if psi2 < 0, psi2 = psi2 + 2*pi; end  % angles within [-pi..pi]    d1 = phi - psi1;    %d1 = diffangle(phi,psi1);    if phi > psi1, while d1 > pi, d1 = d1 - 2*pi; end    elseif psi1 > phi, while d1 < -pi, d1 = d1 + 2*pi; end; end    d2 = phi - psi2;    %d2 = diffangle(phi,psi2);    if phi > psi2, while d2 > pi, d2 = d2 - 2*pi; end    elseif psi2 > phi, while d2 < -pi, d2 = d2 + 2*pi; end; end    if d1*d2 < 0  % different sign means that phi is in between      [Pi,flag] = intersectRayAndSegm([x y phi],F(fIdx,1:4));      %       plot(x,y,'k+');%       hl = plot([x,x+cos(phi)],[y,y+sin(phi)],'k');%       hs = plot([xe1 xe2],[ye1 ye2],'b');%       hi = plot(Pi(1),Pi(2),'r.','MarkerSize',20);%       flag%       keyboard %       delete(hl); delete(hs);            if flag > 0        d = sqrt((x-Pi(1))^2+(y-Pi(2))^2);        if d < dMin + Epsi          dMin = d;          if d > Rs            scanrho = Rs;            scanfID = None;          else            scanrho = d;            scanfID = F(fIdx,6);          end        end      end    end  end    % register visible candidates  if dMin == Inf    scanrho = Rs;    scanfID = None;  end  scan(iscan,1) = phi-xr(3);  scan(iscan,2) = scanrho;  scan(iscan,3) = 0;  scan(iscan,4) = 0;  scan(iscan,5) = scanfID;    iscan = iscan + 1;end