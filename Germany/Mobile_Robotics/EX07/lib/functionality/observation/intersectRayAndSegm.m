% [Pi,flag] = intersectRayAndSegm(ray,sgm);%% Returns Pi = [xi yi]' if intersection with ray = [xr yr phir]% and segment = [xc yc phis len] exists (flag = 1), otherwise:%  flag =  0: segment has been seen from the back (encoded in phi)%  flag = -1: ray is parallel to segment (within global Epsi)%  flag = -2: no intersection with ray%  flag = -3: intersection point is not within segment% v.1.1, 14.12.00, 15.1.01, koa% v.1.2, 19.4.01, koa: Epsi as local constant.% v.1.3,  8.1.02, koa: Bug fix: if abs(sin(dalpha)) >= Epsi,function [Pi,flag] = intersectRayAndSegm(ray,sgm);Epsi = 1E-6;     % used as 0 threshold necessary since e.g. sin(pi)~=0!                 % numerical stable '-pi' for phi comparison (visibility)flag = 1;% Get argumentsxr = ray(1); yr = ray(2); phir = ray(3);xc = sgm(1); yc = sgm(2); phis = sgm(3); len = sgm(4);% Determine alpha and r of segmentd = xc*cos(phis+pi/2) + yc*sin(phis+pi/2);if d > 0,  alphas = phis + pi/2;else  alphas = phis - pi/2;end;rs = xc*cos(alphas) + yc*sin(alphas);			% r now always positiveif (phis < 0) & (phis >= -pi-Epsi),  rs = -rs;  alphas = alphas + pi;		                % sign of r is only det. by phiend;if alphas >= 2*pi, alphas = alphas - 2*pi;elseif alphas < 0, alphas = alphas + 2*pi; end;if ~(rs - xr*cos(alphas) - yr*sin(alphas) > 0),  flag = 0;  rs = -rs; alphas = alphas + pi;  if alphas >= 2*pi, alphas = alphas - 2*pi;  elseif alphas < 0, alphas = alphas + 2*pi; end;end;% Determine alpha and r of rayalphar = phir + pi/2;rr = xr*cos(alphar) + yr*sin(alphar);if rr < 0, alphar = alphar - pi; rr = -rr; end;if alphar >= 2*pi, alphar = alphar - 2*pi;elseif alphar < 0, alphar = alphar + 2*pi; end;% Take alpha-difference and unwrap it keeping its signdalpha = alphar-alphas;if dalpha > pi, dalpha = dalpha - 2*pi;elseif dalpha < -pi, dalpha = dalpha + 2*pi; end;% Intersect if line and ray are not parallelif abs(sin(dalpha)) >= Epsi,  xi = ( rs*sin(alphar)-rr*sin(alphas))/sin(dalpha);  yi = (-rs*cos(alphar)+rr*cos(alphas))/sin(dalpha);    % Take phi-difference and unwrap. Sign unimportant.  phii = atan2(yi-yr,xi-xr);  if phii < 0, phii = phii + 2*pi; end;  % works with atan2  dphi = phir-phii;  if dphi > pi, dphi = dphi - 2*pi;  elseif dphi < -pi, dphi = dphi + 2*pi; end;    % test if ray looks in the good direction and if Pi is within segm.  if abs(dphi) < Epsi,    if sqrt((xc-xi)^2+(yc-yi)^2)-len/2 < Epsi,      Pi = [xi yi]';    else flag = -3; Pi = []; end;  else flag = -2; Pi = []; end;else flag = -1; Pi = []; end;