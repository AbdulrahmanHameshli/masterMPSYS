%DRAWROBOT Draw robot.%   DRAWROBOT(X,COLOR) draws a robot at pose X = [x y theta] such%   that the robot reference frame is attached to the center of%   the wheelbase with the x-axis looking forward. COLOR is a%   [r g b]-vector or a color string such as 'r' or 'g'.%%   DRAWROBOT(X,COLOR,TYPE) draws a robot of type TYPE with a%   symmetrically centered robot coordinate frame. Five different%   models are implemented:%      TYPE = 0 draws only a cross with orientation theta%      TYPE = 1 is a differential drive robot without contour%      TYPE = 2 is a differential drive robot with circular shape%      TYPE = 3 is a circular shaped robot with a line at theta%      TYPE = 4 is a differential drive robot with rectangular shape%      TYPE = 5 is a rectangular shaped robot with a line at theta%%   DRAWROBOT(X,COLOR,TYPE,W,L) draws a robot of type TYPE with%   width W and length L in [m].%%   DRAWROBOT(X,COLOR,CONTOUR,WHEELS) draws a robot with free %   shape and wheel configuation. The struct CONTOUR has fields:%     CONTOUR.POSE:  Offset of contour center as x, y, phi-pose %     CONTOUR.SHAPE: 2xn matrix of points that form closed polygon.%                    Draws standard shape if 1x1 scalar with values%                    0 (circle), 1 (rectangle), 2 (rounded rect.)%     CONTOUR.SIZE:  2x1 vector of length (in x) and width (in y)%                    for the case of a standard shape %   WHEELS is an array of struct of length n with fields:%     WHEELS.POSE: 3x1 Cartesian pose vector x, y, phi where phi%                    is defined as the angle between the robot's%                    x-axis and the horizontal wheel axis%     WHEELS.PARAMS: nx1 vector with wheel parameters. All wheels%                    have radius r and thickness w, caster wheels%                    are given by r, w and displacement d, swedish%                    wheels by r, w and roller angle gamma%     WHEELS.TYPE: Six wheel types are implemented:%                    TYPE = 0 draws a fixed standard wheel%                    TYPE = 1 draws a orientable standard wheel%                    TYPE = 2 draws a passive caster wheel%                    TYPE = 3 draws a motorized caster wheel%                    TYPE = 4 draws a swedish wheel%                    TYPE = 5 draws a ball wheel%   Definitions are due to Campion, Bastin, D'Andrea-Novel,%   IEEE TRA, 1996, except for the pose which we give in Cartesian%   rather than polar coordinates.%%   H = DRAWROBOT(...) returns a column vector of handles to all%   graphic objects of the robot drawing. Remember that not all%   graphic properties apply to all types of graphic objects. Use%   FINDOBJ to find and access the individual objects.%%   See also DRAWWHEEL, DRAWROUNDEDRECT, DRAWARROW, FINDOBJ.% v.1.0, 06.2003, koa, ASL-EPFL% v.1.1, 10.2003, koa, ASL-EPFL: uses drawroundedrect% v.1.2, 12.2003, koa, CAS-KTH : robot types implemented% v.1.3, 12.2023, koa, Uni Stuttgart: different wheel typesfunction h = drawrobot(varargin)% ConstantsDEFT = 2;            % default robot typeDEFB = 0.4;          % default robot width in [m], defines y-dir. of {R}WT   = 0.03;         % wheel thickness in [m]DEFL = DEFB+0.2;     % default robot length in [m]WD   = 0.2;          % wheel diameter in [m]RR   = WT/2;         % wheel roundness radius in [m]RRR  = 0.05;         % roundness radius for rectangular robots in [m]HL   = 0.09;         % arrow head length in [m]CSZ  = 0.1;          % cross size in [m], showing the {R} originCSZF = 0.07;         % same as CS, smaller for free shaped robots% Input argument checkinputerr = 0;switch nargin  case 2    pose  = varargin{1};    color = varargin{2};    type  = DEFT;    B     = DEFB;    L     = DEFL;  case 3    pose  = varargin{1};    color = varargin{2};    type  = varargin{3};    B     = DEFB;    L     = DEFL;  case 4    pose    = varargin{1};    color   = varargin{2};    contour = varargin{3};    wheels  = varargin{4};    type    = 6;    B     = DEFB;    L     = DEFL;  case 5    pose  = varargin{1};    color = varargin{2};    type  = varargin{3};    B     = varargin{4};    L     = varargin{5};  otherwise    inputerr = 1;end% Main switch statementif ~inputerr  x = pose(1); y = pose(2); theta = pose(3);  T = [x; y];  R = [cos(theta), -sin(theta); sin(theta), cos(theta)];    switch type    case 0      % Draw only a cross at origin with orientation theta      p = R*[CSZ, -CSZ, 0, 0; 0, 0, -CSZ, CSZ] + T*ones(1,4);   % horiz. line      h = plot(p(1,1:2),p(2,1:2),p(1,3:4),p(2,3:4),'Color',color);          case 1      % Draw dd robot with centered wheel pair, axis, arrow, no contour      % For backwards compatibility reason xw(3) = theta+pi/2      xw = [x+B/2*cos(theta+pi/2); y+B/2*sin(theta+pi/2); theta+pi/2];      h1 = drawwheel(xw,color);   % left wheel      xw = [x-B/2*cos(theta+pi/2); y-B/2*sin(theta+pi/2); theta+pi/2];      h2 = drawwheel(xw,color);   % right wheel      % Draw axis cross with arrow      p = R*[0, 0; -B/2+WT/2, B/2-WT/2] + T*ones(1,2);      h3 = plot(p(1,:),p(2,:),'Color',color);      p = R*[L/2; 0] + T;      h4 = drawarrow(T,p,1,HL,color);      h = cat(1,h1,h2,h3,h4);          case 2      % Draw dd robot like 1 but with circular contour      % For backwards compatibility reason xw(3) = theta+pi/2      xw = [x+B/2*cos(theta+pi/2); y+B/2*sin(theta+pi/2); theta+pi/2];      h1 = drawwheel(xw,color);   % left wheel      xw = [x-B/2*cos(theta+pi/2); y-B/2*sin(theta+pi/2); theta+pi/2];      h2 = drawwheel(xw,color);   % right wheel      % Draw axis cross with arrow      p = R*[0, 0; -B/2+WT/2, B/2-WT/2] + T*ones(1,2);      h3 = plot(p(1,:),p(2,:),'Color',color);      p = R*[(B+WT)/2; 0] + T;      h4 = drawarrow(T,p,1,HL,color);      % Draw circular contour      radius = (B+WT)/2;      h5 = drawellipse(pose,radius,radius,color);      h = cat(1,h1,h2,h3,h4,h5);          case 3      % Draw circular contour      radius = (B+WT)/2;      h1 = drawellipse(pose,radius,radius,color);      % Draw line with orientation theta with length radius      p = R*[(B+WT)/2;0] + T;      h2 = plot([T(1) p(1)],[T(2) p(2)],'Color',color);      h = cat(1,h1,h2);          case 4      % Draw rectangular contour with wheels, axis and arrow      % For backwards compatibility reason xw(3) = theta+pi/2      xlw = [x+B/2*cos(theta+pi/2); y+B/2*sin(theta+pi/2); theta+pi/2];      h1 = drawwheel(xlw,color);  % left wheel      xrw = [x-B/2*cos(theta+pi/2); y-B/2*sin(theta+pi/2); theta+pi/2];      h2 = drawwheel(xrw,color);  % right wheel      % Draw axis cross with arrow      p = R*[0, 0; -B/2+WT/2, B/2-WT/2] + T*ones(1,2);      h3 = plot(p(1,:),p(2,:),'Color',color);      p = R*[L/2; 0] + T;      h4 = drawarrow(T,p,1,HL,color);      % Draw rectangular contour      h5 = drawrect(pose,L,B,RRR,0,color);      h = cat(1,h1,h2,h3,h4,h5);          case 5      % Draw rectangular contour      h1 = drawrect(pose,L,B,RRR,0,color);      % Draw line with orientation theta with length L      p = R*[L/2; 0] + T;      h2 = plot([T(1) p(1)],[T(2) p(2)],'Color',color);      h = cat(1,h1,h2);          case 6      % Draw robot with free contour and wheel configuration      hw = [];      for i = 1:length(wheels)        h = drawwheel(compound(pose,wheels(i).pose),wheels(i).type,wheels(i).params,color);        hw = cat(1,hw,h);      end      if ~isempty(contour)        if ~isfield(contour,'pose')          contour.pose = zeros(3,1);        end        cpose = compound(pose,contour.pose);        if isfield(contour,'size') && isfield(contour,'shape') && isscalar(contour.shape)              l = contour.size(1);          b = contour.size(2);          if contour.shape == 0   % draw circle            hc = drawellipse(cpose,l/2,b/2,color);          elseif contour.shape == 1    % draw rectangle            hc = drawrect(cpose,l,b,0,0,color);          elseif contour.shape == 2    % draw rounded rectangle            hc = drawrect(cpose,l,b,RRR,0,color);          else            disp('drawrobot: Unsupported robot shape'); hc = [];          end        elseif isfield(contour,'shape') && (size(contour.shape,1)==2)   % free shape          R = [cos(cpose(3)), -sin(cpose(3)); sin(cpose(3)), cos(cpose(3))];          p = R*contour.shape + cpose(1:2)*ones(1,size(contour.shape,2));          hc = plot(p(1,:),p(2,:),'Color',color);        else          disp('drawrobot: Wrong input arguments'); hc = [];        end      else        hc = [];      end      % Draw cross at origin with orientation theta      p = R*[CSZF, -CSZF, 0, 0; 0, 0, -CSZF, CSZF] + T*ones(1,4);   % horiz. line      ho = plot(p(1,1:2),p(2,1:2),p(1,3:4),p(2,3:4),'Color',color);      h = cat(1,hw,hc,ho);    otherwise      disp('drawrobot: Unsupported robot type'); h = [];  endelse  disp('drawrobot: Wrong number of input arguments'); h = [];end