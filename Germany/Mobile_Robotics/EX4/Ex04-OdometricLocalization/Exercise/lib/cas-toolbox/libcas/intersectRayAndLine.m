% [Pi,flag] = intersectRayAndLine(ray,lne);%% Returns [xi yi]' if intersection with ray = [xr yr phir]% and line = [alpha r] exists (flag = 1), otherwise:%  flag =  0: line has been seen from the back (encoded in r)%  flag = -1: ray is parallel to line (within global Epsi)%  flag = -2: no intersection with ray% v.1.1, 14.12.00, 15.1.01, koa% v.1.2, 16.4.01, koa: Epsi as local constant.% v.1.3,  8.0.02, koa: Bug fix: if abs(sin(dalpha)) >= Epsi,function [Pi,flag] = intersectRayAndLine(ray,lne);Epsi = 1E-10;     % used as 0 threshold necessary since e.g. sin(pi)~=0!flag = 1;% Get argumentsxr = ray(1); yr = ray(2); phir = ray(3);alphal = lne(1); rl = lne(2);if ~(rl - xr*cos(alphal) - yr*sin(alphal) > Epsi),  flag = 0;  rl = -rl; alphal = alphal + pi;  if alphal >= 2*pi, alphal = alphal - 2*pi;  elseif alphal < 0, alphal = alphal + 2*pi; end;end;% Determine alpha and r of rayalphar = phir + pi/2;rr = xr*cos(alphar) + yr*sin(alphar);if rr < 0, alphar = alphar - pi; rr = -rr; end;if alphar >= 2*pi, alphar = alphar - 2*pi;elseif alphar < 0, alphar = alphar + 2*pi; end;% Take alpha-difference and unwrap it keeping its signdalpha = alphar-alphal;if dalpha > pi, dalpha = dalpha - 2*pi;elseif dalpha < -pi, dalpha = dalpha + 2*pi; end;% Intersect if line and ray are not parallelif abs(sin(dalpha)) >= Epsi,  xi = ( rl*sin(alphar)-rr*sin(alphal))/sin(dalpha);  yi = (-rl*cos(alphar)+rr*cos(alphal))/sin(dalpha);    % Take phi-difference and unwrap. Sign unimportant.  phii = atan2(yi-yr,xi-xr);  if phii >= 2*pi, phii = phii - 2*pi;  elseif phii < 0, phii = phii + 2*pi; end;  dphi = phir-phii;  if dphi > pi, dphi = dphi - 2*pi;  elseif dphi < -pi, dphi = dphi + 2*pi; end;    % Is Pi on the line?  if abs(dphi) < Epsi,    Pi = [xi yi]';  else flag = -2; Pi = []; end;else flag = -1; Pi = []; end;